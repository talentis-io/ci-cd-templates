name: Notify Webhook

on:
  workflow_call:
    inputs:
      repo_name:
        required: true
        type: string
      branch_name:
        required: true
        type: string
      ai_score:
        required: false
        type: string
        default: "0"
      ai_analysis_html:
        required: false
        type: string
        default: ""
      ai_percentage_advancement:
        required: false
        type: string
        default: "0"

jobs:
  send-kpi:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          repository: ${{ github.repository_owner }}/${{ inputs.repo_name }}
          ref: ${{ inputs.branch_name }}
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Get commit data
        id: commit-data
        run: |
          # Get commit hash
          COMMIT_HASH=$(git rev-parse HEAD)
          
          # Get commit message
          COMMIT_MESSAGE=$(git log -1 --pretty=format:"%s")
          
          # Get branch name
          BRANCH_NAME="${{ inputs.branch_name }}"
          
          # Get commit date
          COMMIT_DATE=$(git log -1 --pretty=format:"%cI")
          
          echo "commit_hash=$COMMIT_HASH" >> $GITHUB_OUTPUT
          echo "commit_message<<EOF" >> $GITHUB_OUTPUT
          echo "$COMMIT_MESSAGE" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT
          echo "branch_name=$BRANCH_NAME" >> $GITHUB_OUTPUT
          echo "created_at=$COMMIT_DATE" >> $GITHUB_OUTPUT

      - name: Notify backend webhook
        if: always()
        env:
          WEBHOOK_URL: ${{ secrets.WEBHOOK_URL }}
          REPO_NAME: ${{ inputs.repo_name }}
          BRANCH_NAME: ${{ inputs.branch_name }}
          RUN_ID: ${{ github.run_id }}
          RUN_NUMBER: ${{ github.run_number }}
          SHA: ${{ github.sha }}
          COMMIT_HASH: ${{ steps.commit-data.outputs.commit_hash }}
          COMMIT_MESSAGE: ${{ steps.commit-data.outputs.commit_message }}
          COMMIT_BRANCH: ${{ steps.commit-data.outputs.branch_name }}
          COMMIT_DATE: ${{ steps.commit-data.outputs.created_at }}
          AI_SCORE: ${{ inputs.ai_score }}
          AI_ANALYSIS_HTML: ${{ inputs.ai_analysis_html }}
          AI_PERCENTAGE_ADVANCEMENT: ${{ inputs.ai_percentage_advancement }}
        run: |
          TS=$(date -u +"%Y-%m-%dT%H:%M:%SZ")

          # Handle empty or null values with defaults
          AI_SCORE=${AI_SCORE:-"0"}
          AI_ANALYSIS_HTML=${AI_ANALYSIS_HTML:-""}
          AI_PERCENTAGE_ADVANCEMENT=${AI_PERCENTAGE_ADVANCEMENT:-"0"}
          COMMIT_MESSAGE=${COMMIT_MESSAGE:-"No commit message"}

          # Clean up newlines but let jq handle all JSON escaping
          COMMIT_MESSAGE_CLEAN=$(echo "$COMMIT_MESSAGE" | tr -d '\n' | tr -d '\r')
          AI_ANALYSIS_HTML_CLEAN=$(echo "$AI_ANALYSIS_HTML" | tr -d '\n' | tr -d '\r')

          PAYLOAD=$(jq -n \
            --arg serverUrl "https://sonarqube.example.com" \
            --arg taskId "AXouyxDpizdp4B1K" \
            --arg projectKey "$REPO_NAME" \
            --arg projectName "$REPO_NAME" \
            --arg projectUrl "https://sonarqube.example.com/dashboard?id=$REPO_NAME" \
            --arg branchName "$BRANCH_NAME" \
            --arg sha "$SHA" \
            --arg run_id "$RUN_ID" \
            --arg run_number "$RUN_NUMBER" \
            --arg commitHash "$COMMIT_HASH" \
            --arg commitMessage "$COMMIT_MESSAGE_CLEAN" \
            --arg commitBranch "$COMMIT_BRANCH" \
            --arg commitDate "$COMMIT_DATE" \
            --arg aiScore "$AI_SCORE" \
            --arg aiAnalysisHtml "$AI_ANALYSIS_HTML_CLEAN" \
            --arg aiPercentageAdvancement "$AI_PERCENTAGE_ADVANCEMENT" \
            '{
              serverUrl: $serverUrl,
              taskId: $taskId,
              project: {
                key: $projectKey,
                name: $projectName,
                url: $projectUrl
              },
              branch: {
                name: $branchName,
                type: "LONG",
                isMain: "true",
                url: ($projectUrl + "&branch=" + $branchName)
              },
              analysis: {
                analysisId: $run_id,
                date: (now | todateiso8601),
                buildString: ("build-" + $run_number),
                revision: $sha
              },
              qualityGate: {
                name: "SonarQube Way",
                status: "OK",
                conditions: []
              },
              measures: [],
              commit: {
                commitHash: $commitHash,
                commitMessage: $commitMessage,
                branchName: $commitBranch,
                createdAt: $commitDate
              },
              aiAnalysis: {
                score: ($aiScore | tonumber),
                analysisHtml: $aiAnalysisHtml,
                percentageAdvancement: ($aiPercentageAdvancement | tonumber)
              }
            }')

          echo "=== WEBHOOK PAYLOAD ==="
          echo "$PAYLOAD" | jq .
          echo "=== END WEBHOOK PAYLOAD ==="

          ATTEMPTS=0; MAX=3; S=2
          until [ $ATTEMPTS -ge $MAX ]; do
            CODE=$(curl -sS -o /tmp/resp.txt -w "%{http_code}" -X POST "$WEBHOOK_URL" \
              -H "Content-Type: application/json" \
              --data "$PAYLOAD" || echo "000")

            if [ "$CODE" = "200" ] || [ "$CODE" = "201" ] || [ "$CODE" = "204" ]; then
              echo "Webhook OK (HTTP $CODE)"
              cat /tmp/resp.txt || true
              exit 0
            fi
            echo "Webhook failed (HTTP $CODE)"
            cat /tmp/resp.txt || true
            ATTEMPTS=$((ATTEMPTS+1))
            echo "Retry $ATTEMPTS/$MAX in ${S}s…"
            sleep $S
            S=$((S*2))
          done

          echo "⚠ Webhook not delivered after $MAX attempts (non-blocking)."